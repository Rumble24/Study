静态库
静态库函数 在 编译 连接的时候 地址就确定了
假设目标文件 A 调用目标文件 B 中的函数foo()，编译时 A 中的调用指令会生成一个 “未解析” 的地址（如call 0x0000）。链接时，链接器确定foo()在最终可执行程序中的地址为0x1000，则会将 A 中的调用指令修正为call 0x1000，确保程序运行时跳转到正确的函数入口。

动态库
* 动态绑定机制：动态库函数在程序运行时才进行绑定。以 iOS/macOS 平台为例，采用 Mach - O 格式，苹果为了能在 Mach - O 文件中访问外部函数，采用了位置代码独立（PIC）技术4。在编译时，会在 Mach - O 的__DATA段中为每一个被引用的系统 C 函数建立一个指针，这个指针在编译时初始化为全 02。在运行时当系统 C 函数被第一次调用时会动态绑定一次，将 Mach - O 中的__DATA段符号表中对应的指针，指向外部函数在共享库中的实际内存地址2。Fishhook 利用了这一特性，通过修改这些指针，将指向系统方法（外部函数）的指针重新进行绑定，指向自定义函数，从而实现对动态库函数的 hook2。
* 静态链接的局限性：静态链接时，程序所依赖的所有目标文件都已经合并在一个可执行文件中，符号项中的符号值（内存地址）在编译链接时就已确定，几乎不存在不确定的情况3。对于自定义的 C 函数，其函数实现和函数调用在同一个 Mach - O 文件中，编译链接时，编译器会直接将函数调用语句和函数实现地址进行链接，不存在动态库函数那种在运行时才确定地址的情况，Fishhook 无法对其进行重定位和地址替换，因此不能 hook 自定义的 C 函数。
* 内存权限问题1：在生成 Mach - O 文件时，内部函数跳转地址通过 PC 寻址已经确定，指令通常被存放在TEXT段，该段权限为只读，无法修改。而 Fishhook 需要修改符号的指针地址来实现 hook，对于TEXT段中只读的内部函数地址无法进行修改，只能对__DATA段中可读写的动态库函数指针进行操作。
