组件化 https://github.com/JumeiRdGroup/JMRouter

使用代理模式 - 定义一个代理 之后每个类进行
内部可以实现 URL/字符串形式

使用runtime 解耦

~~~

@interface WJRouter : NSObject

+ (void)registerRouterWithAppDelegate:(id<UIApplicationDelegate>)applicationDelegate;

+ (void)openWithName:(NSString *)name parameters:(NSDictionary *)parameters object:(id)object;

@end

static NSMutableDictionary<NSString*, NSString*> *routerMap = nil;

@implementation WJRouter


+ (void)registerRouterWithAppDelegate:(id<UIApplicationDelegate>)applicationDelegate {
    if (routerMap != nil) return;
    routerMap = @{}.mutableCopy;
    
    const char *appImage = class_getImageName(self.class);
    unsigned int count = 0;
    const char **classes = objc_copyClassNamesForImage(appImage, &count);
    
    for (unsigned int index = 0; index < count; index++) {
        NSString *className = [NSString stringWithCString:classes[index] encoding:NSUTF8StringEncoding];
        Class class = NSClassFromString(className);
        if ([class conformsToProtocol:@protocol(WJRouterProtocol)] && [class respondsToSelector:@selector(pageName)]) {
            NSString *pageName = [class performSelector:@selector(pageName)];
            routerMap[pageName] = className;
        }
        NSLog(@"className %@", className);
    }
    free(classes);
}

+ (void)openWithName:(NSString *)name parameters:(NSDictionary *)parameters object:(id)object {

    @try {
        Class cls = NSClassFromString(routerMap[name]);
        // 1. 检查类是否遵循协议
        if (![cls conformsToProtocol:@protocol(WJRouterProtocol)]) {
            NSLog(@"❌ %@ 不遵循 WJRouterProtocol", NSStringFromClass(cls));
            return;
        }
        NSString *pageName = [cls performSelector:@selector(pageName)];
        NSLog(@"✅ pageName %@", pageName);
        
        UIViewController *vc = [cls performSelector:@selector(createWithParameters:object:) withObject:parameters withObject:object];
        UIViewController *nav = [WJRouter df_getCurrentVC];
        if ([nav isKindOfClass:[UINavigationController class]]) {
            [((UINavigationController *)nav) pushViewController:vc animated:YES];
        }
    }
    @catch (NSException *exception) {
        NSLog(@"❌ 调用 %@ 的 pageName 时发生异常: %@", name, exception);
    }
}

+(UIViewController *)df_getCurrentVC {
    UIViewController *result = nil;
    
    UIWindow * window = [[UIApplication sharedApplication] keyWindow];
    if (window.windowLevel != UIWindowLevelNormal)
    {
        NSArray *windows = [[UIApplication sharedApplication] windows];
        for(UIWindow * tmpWin in windows)
        {
            if (tmpWin.windowLevel == UIWindowLevelNormal)
            {
                window = tmpWin;
                break;
            }
        }
    }
    
    UIView *frontView = [[window subviews] objectAtIndex:0];
    id nextResponder = [frontView nextResponder];
    
    if ([nextResponder isKindOfClass:[UIViewController class]])
        result = nextResponder;
    else
        result = window.rootViewController;
    
    return result;
}

@end
~~~

## 日志系统 实时日志/写入本地文件日志
抖音日志系统：https://juejin.cn/post/7383880021821587468
1.怎么写 
  1.日志分级 - 上报那个分级 - 云控
  2.日志分层 - 暗中模块划分 - 运营日志/运维/技术/
  2.日志写入本地的时候 大量io操作 定时器 合并写入
  3.天为单位写入文件
  4.日志每条上报
日志淘汰策略 只保留一星期的日志 / 只保留100m的日志 多余的进行删除  

2.怎么报
 1.用户点击反馈的时候上报
 2.长链接 连接上的时候上报


实时日志 - 写入数据库 空闲的时候上报 - 日志报警系统【发现问题快速解决的能力】
选择合适的数据库写入 - 定义通用的字段 方便解析 数据加密 - 
多条合并上传 - 还有 数据压缩算法 

日志要建立索引 方便查询
大部分日志 由相同的key。可以建立映射 这样发送日志 的时候数据量小很多
