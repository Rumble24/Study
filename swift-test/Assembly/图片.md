#  图片解码
// 先获取完整图像（仅解码一次）内存涨了8M
CGImageRef fullImage = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);  基本不占内存
// 预解码  内存涨了80M
UIImage *img = [croppedImage imageByPreparingForDisplay]; 生成bitmap。如果没有解码会进行解码
这个图片可以直接显示在屏幕上

和 UIImage *img = [UIImage imageWithData:data]; 一样


长图的二进制数据只有 5M

# 原因
通过所有CGImageSourceCreateImageAtIndex这种API生成的CGImage，其实它的backing store（就是Bitmap）还没有立即创建，他只是一个包含了一些元信息的空壳Image。这个CGImage，在最终需要获取它的Bitmap Buffer的时候（即，通过相应的API，如CGDataProviderCopyData，CGDataProviderRetainBytePtr），才会触发最后的Bitmap Buffer的创建和内存分配。
