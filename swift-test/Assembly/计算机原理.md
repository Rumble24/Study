
汇编和机器指令是可逆的 一对一的

cpu 和 内存 连接 
地址总线 - 寻址能力 8 个管线 最大可以寻找 2 的8次方的地址
数据总线 - 传输数据 8 个管线 可以 传输 1个字节的数据
指令总线 - 传输指令

8086 是 20宽度的地址总线
但是他是16位的 所以是两个16位的合成一个20位的数据 一个段地址。和 一个偏移地址
计算方法为  段地址 * 16 + 偏移地址

8086 采用 20 位地址总线而非 32 位，是技术限制、成本控制、实际需求与兼容性共同作用的结果：
16 位架构是当时的技术主流，32 位设计在成本和复杂度上不可行；
1MB 内存足以满足早期应用，无需 32 位地址总线的 “过剩性能”；
分段寻址方案用最小的硬件改动实现了内存扩展，同时兼容既有软件生态。

CPU = 寄存器 + 运算器 + 控制器
8086 有 14个寄存器

iOS的内存有
内核区
栈区
堆区
数据去。全局变量/静态变量/常量
代码区

对应的cpu的寄存器

数据寄存器 - AX/BX/CX/DX
指针寄存器 p


堆栈寄存器 stack segment
数据寄存器 data segment
代码寄存器 code segment 
附加寄存器 extra segment

架构位数 = 寄存器宽度 8086 是16位 只能放两个字节

mov bx,1000H
mov ds,bx
mov al,[0]
上面3条指令的作用将10000H（1000:0）中的内存数据赋值到al寄存器中
mov al,[address]的意思将DS:address中的内存数据赋值到al寄存器中
由于al是8位寄存器，所以是将一个字节的数据赋值给al寄存器



# 汇编 指令
jmp 指令 jmp 段地址：偏移地址 cpu直接跳转指定的目标地址继续执行
mov ax,bx  ax = bx
add ax,bx  ax = ax + bx
sub ax,bx  ax = ax - bx

db 定义一个字节
dw 定义两个字节 word

db 10 dup(0)  重复定一个10个0


### int n产生中断
int 10h用于执行BIOS中断
int 3是“断点中断”，用于调试程序
int 21h用于执行DOS系统功能调用，AH寄存器存储功能号
mov ah,4c00h
int 21h

### 栈 ss
sp 栈顶
bp 辅助栈数据
是两个字节 两个字节操作的
push ax  将 ax 赋值给 ss:sp的内容 移动栈帧
pop ax 将 ss:sp的内容 赋值给 ax 移动栈帧

### call 和 ret [return]
call 执行某个函数  下面的函数入栈
ret 函数出栈 ret 4 可以出栈4次
函数调用要保证堆栈平衡

data segment
    db 10h
    string db 'Hello World!$'
data end

code segment

start:
    move ax,data
    move ds,ax
    
    call print // 下一行入栈
    
    call math
    mov bx, ax // 函数的返回值一般放在ax

    push 1122h
    push 2233h
    call sum
    add sp,4  ;恢复栈平衡
    
    mov ax,4c00h
    int 21h
    
print:
    mov dx, offset string
    mov ax,9h
    int 21h
    
    ret // 回到原来的位置

math:
    mov ax,2
    add ax,ax
    add ax,ax
    ret  
    
// 函数参数
sum:
    mov bp,sp // 不允许直接操作 sp
    mov ax,ss:[bp+2]
    add ax,ss:[bp+4]
    ret 

code end

end start


/*

0h
02h
44h <-
33h
22h
11h
*/


## 函数
函数的返回值一般放在ax
参数放在栈里面 最后要进行栈平衡

函数互相调用 栈空间会一直📈
一个一个调用 会出栈 

内平衡 和 外平衡 一般是外平衡
