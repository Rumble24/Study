
汇编和机器指令是可逆的 一对一的

cpu 和 内存 连接 
地址总线 - 寻址能力 8 个管线 最大可以寻找 2 的8次方的地址
数据总线 - 传输数据 8 个管线 可以 传输 1个字节的数据
指令总线 - 传输指令

8086 是 20宽度的地址总线
但是他是16位的 所以是两个16位的合成一个20位的数据 一个段地址。和 一个偏移地址
计算方法为  段地址 * 16 + 偏移地址

8086 采用 20 位地址总线而非 32 位，是技术限制、成本控制、实际需求与兼容性共同作用的结果：
16 位架构是当时的技术主流，32 位设计在成本和复杂度上不可行；
1MB 内存足以满足早期应用，无需 32 位地址总线的 “过剩性能”；
分段寻址方案用最小的硬件改动实现了内存扩展，同时兼容既有软件生态。

CPU = 寄存器 + 运算器 + 控制器
8086 有 14个寄存器

iOS的内存有
内核区
栈区
堆区
数据去。全局变量/静态变量/常量
代码区

对应的cpu的寄存器

数据寄存器 - AX/BX/CX/DX
指针寄存器 bp sp 栈顶/栈底


堆栈寄存器 stack segment
数据寄存器 data segment
代码寄存器 code segment 
附加寄存器 extra segment

架构位数 = 寄存器宽度 8086 是16位 只能放两个字节

mov bx,1000H
mov ds,bx
mov al,[0]
上面3条指令的作用将10000H（1000:0）中的内存数据赋值到al寄存器中
mov al,[address]的意思将DS:address中的内存数据赋值到al寄存器中
由于al是8位寄存器，所以是将一个字节的数据赋值给al寄存器



# 汇编 指令
jmp 指令 jmp 段地址：偏移地址 cpu直接跳转指定的目标地址继续执行
mov ax,bx  ax = bx
add ax,bx  ax = ax + bx
sub ax,bx  ax = ax - bx

db 定义一个字节
dw 定义两个字节 word

db 10 dup(0)  重复定一个10个0


### int n产生中断
int 10h用于执行BIOS中断
int 3是“断点中断”，用于调试程序
int 21h用于执行DOS系统功能调用，AH寄存器存储功能号
mov ah,4c00h
int 21h

### 栈 ss
sp 栈顶
bp 辅助栈数据
是两个字节 两个字节操作的
push ax  将 ax 赋值给 ss:sp的内容 移动栈帧
pop ax 将 ss:sp的内容 赋值给 ax 移动栈帧

### call 和 ret [return]
call 执行某个函数  下面的函数入栈
ret 函数出栈 ret 4 可以出栈4次
函数调用要保证堆栈平衡

data segment
    db 10h
    string db 'Hello World!$'
data end

code segment

start:
    move ax,data
    move ds,ax
    
    call print // 下一行入栈
    
    call math
    mov bx, ax // 函数的返回值一般放在ax

    push 1122h
    push 2233h
    call sum
    add sp,4  ;恢复栈平衡
    
    mov ax,4c00h
    int 21h
    
print:
    mov dx, offset string
    mov ax,9h
    int 21h
    
    ret // 回到原来的位置

math:
    mov ax,2
    add ax,ax
    add ax,ax
    ret  
    
// 函数参数
sum:
    mov bp,sp // 不允许直接操作 sp
    mov ax,ss:[bp+2]
    add ax,ss:[bp+4]
    ret 

code end

end start


/*

0h
02h
44h <-
33h
22h
11h
*/


## 函数
函数的返回值一般放在ax
参数放在栈里面 最后要进行栈平衡

函数互相调用 栈空间会一直📈
一个一个调用 会出栈 

内平衡 和 外平衡 一般是外平衡
函数调用约定

__cdecl 外平栈，参数从右从右到左入栈
__stdcall 内平栈，参数从右到左入栈
__fastcall 内平栈，eax,edx分别传递前面2个参数，其他参数从右到左入栈

iOS 使用的快速调用 函数参数都是放在寄存器 8 9 个寄存器 不使用栈 还要出栈 入栈 和总线 直接在cpu里面比较快

# 临时变量
bp加 参数
bp-访问 局部变量

assume cs:code ,ds:data,ss:stack

stack segment

stack ends     


data segment
    string db 'hello$'
data ends


code segment                                 
start:

    mov ax,data
    mov ds,ax
    
    mov ax,stack
    mov ss,ax
    
    ;业务逻辑
    
    push 1
    push 2
    call sum
    add sp,4 
    
    ;退出
    mov ax,4c00h
    int 21h  
 
sum:       

    push bp    ; 保护bp
    ;访问栈参数  
    ;保存bp以前的值
    mov bp,sp
    sub sp,10    ; 预留十个字节给局部变量
    
    ;保护可能会用到的寄存器
    
    push si
    push di
    push bx
                    
     ;业务逻辑               
    ;定义两个局部变量
    
    mov word ptr ss:[bp-2],3
    mov word ptr ss:[bp-4],4 
    mov ax,ss:[bp-2]
    add ax,ss:[bp-4]
    mov ss:[bp-6],ax
                   
    mov si,1
    
    ;访问栈中的参数
    mov ax,ss[bp+2]
    add ax,ss:[bp+4]  
    add ax,ss:[bp-6]         
                           
     ;业务逻辑                       
    
    ; 恢复寄存器值
    pop bx
    pop di
    pop si
                           
    mov sp,bp ; 恢复sp
    pop bp
    
    ret       
    
code ends  
end start

# stosw ax的值写入 es:di中 同时 di的值加2
# rep 重复 重复次数 有 cx决定
临时变量全部写入 0cccch
mov ax, 0cccch
mov bx,ss
mov es,bx
mov di,bp
add di,2
mov cx,5
rep stosw


# 破解 
先使用 01-CrackMe 获取到那行代码的地址
然后使用 OllyDBG v2.01 修改源代码

## AT&T
lea 是 Load Effective Address（加载有效地址） 的缩写，它的核心功能是计算内存地址并将其加载到寄存器中，而非加载该地址中的数据。这一特性使得 lea 既可以用于地址计算，也能被灵活用作简单的算术运算。
mov reg, [addr]：加载 addr 地址中存储的数据 到寄存器（访问内存）。
lea reg, [addr]：计算 addr 本身的数值 并加载到寄存器（不访问内存，仅做地址计算）。
movabsq 处理超过 32 位的立即数或绝对地址

# ARM
## 寄存器
### 通用寄存器    31个    x0-x30（64 位），低 32 位可单独访问（命名为 w0-w30，如 x0 的低 32 位为 w0）。
- x0-x7：用于函数参数传递和返回值；
- x8：间接返回值寄存器；
- x9-x15：临时寄存器；
- x16-x17：内部调用寄存器；
- x18：平台寄存器（如 macOS 中用于线程局部存储）；
- x19-x28：保存寄存器（函数调用需保留）；
- x29：帧指针（FP）；
- x30：链接寄存器（LR，存储函数返回地址）。
程序计数器    1个   
  pc（64 位）：存储下一条要执行的指令地址，不能直接修改（通过分支指令间接更新）。
状态寄存器    多个  
  如 spsr（保存程序状态寄存器）、cpsr（当前程序状态寄存器），用于存储标志位（如零标志 Z、进位标志 C 等）和 CPU 状态。
栈指针    1 个 
  sp（64 位）：指向当前栈顶，支持栈对齐检查（通常要求 16 字节对齐）。
### cpsr 状态寄存器
31 n: 是非为负数 1是0否
30 z：释放为0
29 c：进位标志 
    加法（add）：若结果超过无符号数的最大值（如 32 位加法结果 ≥ 2³²），则 C=1（进位）。
    减法（sub）：若被减数小于减数（无符号数），则 C=0（借位，此时实际借位标志需通过 C=0 判断）。
    移位（lsl）：若移位后最高位被移出 1，则 C=1。
28 v：仅用于有符号数运算，若结果超出有符号数的表示范围，则 V=1。例如： 32 位有符号数的最大值为 0x7FFFFFFF（2¹⁷-1），若 add r0, r1, r2 中 r1 和 r2 均为正数，且和 ≥ 2¹⁷，则 V=1。

### pc 当前执行寄存器 
### fp x29 
### lr x30 链接寄存器 存贮函数的返回地址

# ARM 指令
### stp x29, x30, [sp, #-16]! 批量存储一对寄存器
### str x20, [sp, #0x30]  sp + 0x30 地址8个字节存入到 x20 如果是 w20那么是存入4个字节
### str wzr, [sp, #0xc] 要求自然对齐（如 64 位需 8 字节对齐）    操作：将 wzr（零寄存器，32 位，值恒为 0）存储到栈地址 sp + 0xc（栈指针偏移 +12 字节）。
### stur <源寄存器>, [<基址寄存器>, #偏移量]  允许非对齐访问（无严格对齐要求） 
### sturb  wzr, [x29, #-0x18]
    st：存储（Store）操作，将寄存器数据写入内存。
    u：无符号（Unsigned），此处表示按字节（8 位）存储，无需符号扩展。
    r：带寄存器偏移（Register offset），内存地址由基址寄存器加偏移量计算。
    b：操作的数据宽度为字节（Byte，8 位）。

### ldr  x0, [sp, #0x8]  读取数据 sp+8 到x0
### ldr  x0, [sp, #0x8]!  读取数据 sp+8 到x0 并且改变sp 的值
### ldur x0, [sp, #0x8]  允许非对齐访问（无严格对齐要求） 
### ldp  x29, x30, [sp, #-16]! 批量加载一对寄存器


### cbz w8, <目标地址> 直接判断寄存器是否为零
这条指令会直接检查寄存器 w8 的值：
如果 w8 == 0（寄存器值为零），则跳转到 0x100000644 处执行代码。
如果 w8 != 0（寄存器值非零），则不跳转，继续执行下一条指令。

### cmp 操作数1, 操作数2
两个数相减 更新状态寄存器（如 ARM 的 CPSR、x86 的 EFLAGS）中的标志位，
add sub 会保存值，并且更新状态寄存器

### and 是按位与指令，用于对两个操作数执行按位与运算，并将结果存入目标寄存器
### adds 
### subs w8, w8, #0x1
操作：32 位减法并设置标志位，计算w8 - 1（即7 - 1 = 6）。
关键：subs更新状态寄存器，此处结果 6≠0，零标志Z=0。
作用：计算var - 1，为判断 “var是否等于1” 做准备（若var=1，则1-1=0，Z=1）。

### b.eq 0x100000658
b.eq（Equal）条件分支：若subs结果为 0（即var - 1 == 0 → var=1），则跳转到0x100000658（<+88>）

eq    Equal    Z=1    op1 == op2（结果为 0）
ne    Not Equal    Z=0    op1 != op2（结果非 0）
ge    Greater or Equal    N=V（符号位与溢出位相同）    有符号数：op1 ≥ op2
lt    Less Than    N≠V（符号位与溢出位不同）    有符号数：op1 < op2
gt    Greater Than    Z=0 且 N=V    有符号数：op1 > op2
le    Less or Equal    Z=1 或 N≠V    有符号数：op1 ≤ op2

### blr x0   跳转到 x0 指向的函数，并将返回地址存入 x30（ARM64 的 lr）
### ret 将lr的指令存储到pc里面


### adrp <目标寄存器>, <页偏移量>  大概就是生成一个页，来存放寄存器


# LLVM

LLVM 广义 指的是整个LLVM项目 狭义 指的是 LLVM后端

前段 + IR + 后端

clang 前端 [C/C++/OC]
预处理 clang -E main.m
词法分析，生成Token： $ clang -fmodules -E -Xclang -dump-tokens main.m
语法分析，生成语法树（AST，Abstract Syntax Tree）： $ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m
语义分析 - 在语法分析的基础上分析 不合规那么报错
中间代码IR: clang -S -fobjc-arc -emit-llvm main.m
后端处理生成 - 后端生成汇编代码 - 机器吗     clang -S -fobjc-arc main.bc -o main.s / clang -S -fobjc-arc main.ll -o main.s


// https://llvm.org/docs/LangRef.html
LLVM IR有3种表示形式（但本质是等价的，就好比水可以有气体、液体、固体3种形态）
text：便于阅读的文本格式，类似于汇编语言，拓展名.ll， $ clang -S -emit-llvm main.m
memory：内存格式
bitcode：二进制格式，拓展名.bc， $ clang -c -emit-llvm main.m


### clang 命令行指令
register read 读取寄存器
register write 写入寄存器
next/nexti/step/stepi/si 执行下一行代码
c containue 的意思 继续

# Swift的前端编译器是Swift Complier
生成语法树AST：swiftc -dump-ast main.swift
生成最简洁的SIL代码：swiftc-emit-sil main.swift
生成LLVM IR代码：swiftc -emit-ir main.swift -o main.ll
生成汇编代码：swiftc -emit-assembly main.swift -o main.s

# 代码混淆 - class-dump工具
ios-class-guard
#### define 字符串重定义
字符串混淆

# Mach-O
分析 swift无用代码

# 通过扫描语法树获取所有的类

# 网络HTTP - 见网络/HTTP相关

# 算法

# 音视频
