

# 动态加载管理（Dynamic Loader Info）
在 Mach-O 二进制文件中，Rebase Info（重定位信息）和 Binding Info（绑定信息）系列（包括弱绑定、延迟绑定、导出信息）是动态链接过程的核心元数据，用于解决二进制在内存加载时的地址依赖问题，确保函数调用和变量访问的正确性。它们由编译器生成，供动态加载器（dyld）在程序启动或运行时使用。以下是详细解析：
## 一、Rebase Info（重定位信息）
核心作用：解决二进制内部的地址偏移问题。当二进制被加载到内存时，其实际地址（virtual address）可能与编译时假设的地址（link address）不同（因 ASLR 随机化或内存布局变化），Rebase Info 记录了所有需要修正的内部地址，确保它们指向正确的内存位置。

为什么需要重定位？

    编译时，编译器假设二进制会被加载到固定地址（如 0x100000000），因此内部引用（如函数调用、全局变量访问）会使用相对于该地址的偏移量。
    实际加载时，ASLR（地址空间布局随机化）会随机分配加载地址，导致原偏移量失效。例如：编译时假设函数 A 在 0x100001000，变量 x 在 0x100002000，函数 A 中访问 x 的代码会生成 0x100002000 的地址；若实际加载地址变为 0x100008000，x 的实际地址是 0x10000A000，此时需要通过重定位修正函数 A 中访问 x 的地址。

存储内容：

    一系列 “重定位条目”，每个条目包含：
    需要修正的内存地址（相对于二进制的偏移量）；
    修正类型（如指针、函数地址等）；
    目标地址所在的段或符号信息。

处理时机：
    dyld 在加载二进制到内存后，会先执行重定位（rebasing），遍历 Rebase Info 中的所有条目，根据实际加载地址修正相关内存位置，确保内部引用正确。
    
## 二、Binding Info（绑定信息）
核心作用：解决二进制对外部符号（如动态库中的函数 / 变量）的引用。当二进制使用其他库（如系统库 UIKit、libc）中的符号时，Binding Info 记录了这些符号的位置和关联规则，指导 dyld 在加载时将引用绑定到实际地址。

与 Rebase 的区别：

    Rebase 处理内部地址（二进制自身定义的符号）；
    Binding 处理外部地址（其他库定义的符号）。

存储内容：
    每个绑定条目包含：

    引用外部符号的内存地址（二进制中需要填充实际地址的位置）；
    符号名称（如 NSLog、UIView_init）；
    符号所在的库（如 Foundation.framework、libSystem.B.dylib）；
    绑定类型（如强引用、弱引用）。

处理时机：
    dyld 在重定位完成后执行绑定（binding），根据 Binding Info 查找外部符号在内存中的实际地址，填充到二进制的引用位置。例如：二进制中调用 NSLog 的代码会预留一个地址位，dyld 找到 NSLog 在 Foundation 库中的实际地址后，将其写入该位置。
## 三、Weak Binding Info（弱绑定信息）
核心作用：处理对外部符号的弱引用（weak reference），允许符号不存在时不报错，而是将引用指向 NULL。

弱引用的场景：

    兼容不同版本的系统库：例如，程序使用了新系统的 API（如 iOS 15+ 的 someNewFunction），但需要在旧系统（iOS 14）上运行，此时可对该函数进行弱绑定 —— 在旧系统中符号不存在，引用会被设为 NULL，程序可通过判断 NULL 来兼容处理。
    可选依赖：当某个功能依赖的库可能不存在时，弱绑定可避免程序因找不到符号而崩溃。

与普通 Binding 的区别：

    普通绑定（Binding Info）要求符号必须存在，否则 dyld 会抛出 “符号未找到” 错误（dyld: Symbol not found）；
    弱绑定允许符号不存在，此时引用会被设为 NULL，程序可通过判断 if (someWeakSymbol != NULL) 来安全处理。
## 四、Lazy Binding Info（延迟绑定信息）
核心作用：优化启动速度，将不常用的外部符号绑定推迟到第一次使用时，而非程序启动阶段。

为什么需要延迟绑定？
    程序可能引用了大量外部符号，但很多符号在启动阶段不会被调用（如某个按钮点击事件的处理函数）。若所有符号都在启动时绑定，会增加启动时间。延迟绑定通过 “按需绑定” 减少启动时的工作量。

工作机制：

    编译时，对延迟绑定的符号，编译器会生成一个 “桩函数（stub）”，存放在 __TEXT,__stubs 段；
    程序首次调用该符号时，会先执行桩函数，桩函数触发 dyld 进行绑定（查找实际地址）；
    绑定完成后，桩函数会被修改为直接跳转到实际地址，后续调用不再经过 dyld。

典型场景：
    大部分系统库函数（如 printf、UIAlertController 初始化方法）都使用延迟绑定，因为它们通常不会在程序启动时立即调用。
## 五、Export Info（导出信息）
核心作用：记录当前二进制对外提供的符号（即其他二进制可引用的函数、变量或类），是二进制 “暴露给外部的接口清单”。

存储内容：

    导出符号的名称（如 -[MyViewController setupUI]、globalConfig）；
    符号在当前二进制中的内存地址（或偏移量）；
    符号的可见性（如公开、私有）和类型（函数、变量等）。

应用场景：

    动态库（.dylib 或 .framework）必须通过 Export Info 声明对外提供的接口，否则其他程序无法引用其内部符号；
    逆向分析中，解析 Export Info 可快速了解一个库提供的功能（如通过导出的 encryptData: 函数推测库涉及加密）。
    总结：动态链接的完整流程
    这些信息的协同工作确保了 Mach-O 二进制在动态加载时的正确性，流程如下：

加载与重定位（Rebase）：dyld 将二进制加载到内存，根据 Rebase Info 修正内部地址，解决 ASLR 导致的偏移问题；
绑定外部符号（Binding）：根据 Binding Info 绑定启动时必需的外部符号（如初始化函数）；
延迟绑定（Lazy Binding）：首次调用某个外部符号时，通过 Lazy Binding Info 完成绑定，优化启动速度；
弱绑定处理（Weak Binding）：对弱引用符号，若不存在则设为 NULL，避免崩溃；
导出符号（Export Info）：供其他二进制引用当前二进制的符号。

理解这些信息对于逆向分析（如符号修复、动态库接口解析）和调试（如解决 “符号未找到” 错误）至关重要。

