 
/*
 1、MVC的一些缺点
 业务逻辑复杂起来的时候我们的Controller会越来越庞大，导致维护性降低
 2、讲一讲其它架构
 MVVM - 增加viewmodel层处理数据 将一些业务逻辑放在viewmodel层处理
 3、你知道哪些编码方式
 刚开始使用的是acccode编码 后来不够用了 使用了
 unicode编码 - 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储
 UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式
 4、算法字符串翻转
 5、多线程的方式和它们的区别
 
 nsthread 最底层的类 - 需要自己管理线程的生命周期 创建 -开启 - 销毁
 NSOperation 是对GCD的面相对象的封装 - 基于 NSOperation 和 NSOperationQueue 自动管理线程的生命周期 实现最大并发数 支持任务的优先级 依赖 和取消
 GCD 偏向底层 不直接支持任务依赖 简单易用
 
 6、队列和线程的关系
 队列是管理任务的
任务可以是异步任务/同步任务 异步任务会开启新的线程
 
 7、一道线程安全的题
 8、有哪些锁 iOS 中的锁底层只有两种 自旋锁和互斥锁 其他的都是基于这个的封装
 不同线程获取加锁 必须是 处于已解锁状态 否则就是i一直等
 23、自旋锁和互斥锁的区别
 互斥锁- 当锁被占用，而其他线程申请锁时，不是使用忙等，而是阻塞线程并睡眠.
 自旋锁 - 忙等
 
 os_unfair_lock
 OSSpinLock 自旋锁 废弃 会导致优先级反转
 nslock 不能嵌套使用 会导致 死锁
 nsresicelock 递归锁 同一个线程可以嵌套使用。不同线程嵌套使用会导致死锁 - 使用信号量
 当同一线程递归调用获取锁时：
 检查当前持有锁的线程 ID 是否等于自己。
 若相等，则允许获取锁，并增加计数器。
 释放锁时，减少计数器，直到计数器为 0 时真正释放锁。
 
 若锁已被其他线程持有（无论计数器多少），当前线程必须等待
 不同线程间的锁请求仍需遵循互斥原则，无法通过递归锁特性绕过。

 
 
 条件锁
 信号量 注意使用 导致死锁
 @@synchronized - 只能作用于OC对象 底层基于 地柜锁实现 - //obj为nil时,什么也不做
 dispatch_queue_t 穿行队列 - 性能优于大多数显式锁（GCD 底层优化）。
 
 9、属性的关键字
 atomic nonatomic strong assign weak
 10、assign可以用于OC对象吗
 不可以 会导致 野指针 不回引用计数加一
 11、copy和strong的区别
 strong 会引用计数加一
 copy深拷贝会生成新的对象
 12、weak如何实现自动赋nil
 weak修饰对象的时候，会以对象为 key 放入若引用表里面释放的时候 在这里找到职位nil
 13、为什么不可变对象要用copy
 14、assing可以使用在对象中吗。可以，但是不建议 不回引用计数加1 会导致野指针
 15、Pod update和pod install的区别
 16、layoutIfNeeded和setNeedsLayout的区别
 layoutIfNeeded - 立即更新布局 - 调用drawRect
 setNeedsLayout - 下一阵执行 - 不处罚drawRect

 18、isEquel和hash的关系
 isEquel 默认比较内存地址 重写的话 可以用于比较 逻辑相等
 hash 默认返回内存地址 用户哈希表的快速查找 值一样那么 key就一样
 如果重写了 isEquel  没有重写 hash 那么set里面会有两个对象
 
 21、如何hook一个对象的方法，而不影响其它对象
利用kvo的实现
 
 17、抓包工具抓取HTTPS的原理
 抓包工具通过伪造证书 + 中间人代理的方式，在客户端和服务器之间建立双重 TLS 连接，实现 HTTPS 数据的解密和拦截。理解这一原理有助于开发人员调试网络问题，同时也提醒我们需要通过证书钉扎等技术保护应用安全。

 19、bitmap的结构
 20、可变数组的实现原理
 分配新内存：创建一个更大的新数组（通常容量翻倍）。
 复制元素：将原数组的所有元素复制到新数组。
 释放旧内存：销毁原数组的内存空间。
 更新指针：指向新数组的内存地址。
 
 三面
 1、介绍项目，主要介绍自己强项一点的地方
 2、数组cop后里面的元素会复制一份新的吗
 3、数组的浅拷贝与深拷贝
 4、TCP为什么是三次握手和四次挥手
 */
