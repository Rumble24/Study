#iOS在触摸屏幕后发生了什么？https://juejin.cn/post/7374968339905413130
1.系统响应阶段
 屏幕感受触摸后，将事件交给iokit处理，ioKit是苹果检测硬件的框架，生成一个iohidevent事件通过mach port 传递给springboard进程
 #####mach port是进程端口，各个进程之间通过它进行通信；SpringBoard.app是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件；
 
SpringBoard.app进程收到触摸事件，触发主线程RunLoop的source1事件源的回调。
SpringBoard.app会根据当前桌面的状态，判断应该由谁响应此次触摸事件。
如果没有APP在运行，则由SpringBoard处理该事件；
如果有APP在运行，则由APP处理该事件；

2.APP响应阶段
1、APP进程的mach port接收到SpringBoard进程传递来的触摸事件，主线程的RunLoop被唤醒，触发source1回调；
2、source1回调触发了一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象；
3、source0回调内部将触摸事件添加到UIApplication对象的事件队列中。事件出队列后，UIApplication开始寻找一个最佳响应者的过程，这个过程又称为hit-testing，具体细节在第二个主题寻找最佳响应者中阐述；
4、找到最佳响应者后，事件就在响应链中传递和响应，这里涉及到“事件的响应和响应链中的传递”；
5、经过上述流程，触摸事件要么被某个响应对象捕获后释放，要么没有找到能响应的对象被释放；

三、寻找事件最佳响应者（Hit-Testing）
应用接收到事件后先将其放入事件队列中等待处理。出队列后，UIApplication首先将事件传递给当前应用最后显示的窗口（UIWindow）询问其能否响应事件，若窗口能响应事件，则传递给子视图询问是否能响应，子视图继续询问子视图。子视图询问的顺序是优先询问后添加的子视图。
事件传递顺序如下：
UIApplication -> UIWindow -> 子视图 -> ... -> 子视图  判断点击的点是否在这个试图上面

四、事件的响应和在响应链中的传递
响应者对于事件的拦截和传递都是通过touchesBegan:withEvent:方法控制的，该方法的默认实现是将事件沿着默认的响应链往下传递。
响应者接收到事件后有3种操作：
1、不拦截，向下分发事件（默认操作）
事件会自动沿着默认的响应链向下传递，系统默认实现会调用[super touchesBegan:touches withEvent:event]，写测试代码时注意。
2、拦截，不再向下分发事件
实现方式是重写touchesBegan:withEvent:进行事件处理，不调用[super touchesBegan:touches withEvent:event]。
3、拦截，继续向下分发事件
实现方式是重写touchesBegan:withEvent:进行事件处理，同时调用super touchesBegan:touches withEvent:event]将事件往下传递。

< UIRespnder < UIGestureRecognizer < UIControl，笼统地讲，事件响应优先级依次递增。

# 问：为什么UIcollectionView添加 单击手势之后，无法响应didSelectItemAt
默认情况下手势识别成功之后 不会再将事件在响应者链下面传递下去，所以说就无法响应了
        let tap = UITapGestureRecognizer(target: self, action: #selector(tapAction))
        tap.cancelsTouchesInView = false
        self.view.addGestureRecognizer(tap)
可以解决这个问题
/*
 touchbegin 事件刚刚开始 还没有正确的事件
 touchbegin 走的是 UIResponder 体系
 手势走的是手势识别器 识别了手势也会走响应者链 延续下去 touchbegin  但是无法生成正确的事件
 设置cancletouchs 可以让响应者链生成正确的事件
 */
# 问：
