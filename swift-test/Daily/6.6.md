一面
iOS反射机制 - 基于runtime实现的
使用runtime我们可以拿到对象的成员变量 属性 方法 

iOS的timer和CADisplay的区别
首先都是基于runloop实现的

不用第三者，怎么交换两个数
基于运算 可能会溢出
位运算

二面
## UI的渲染步骤，视图打包流程，cpu和gpu工作，为什么要双缓冲区
###渲染步揍

在 iOS 的 UI 渲染流程中，CPU 和 GPU 分工明确，而 **Core Graphics、Core Animation、Core Image** 等框架则在不同阶段发挥关键作用。以下从渲染步骤、CPU/GPU 职责、框架角色三个维度展开说明：


### **一、UI 渲染核心步骤与 CPU/GPU 分工**
#### **1. CPU 阶段：数据准备与逻辑处理**
- **布局计算（Layout）**  
  - 职责：计算视图的几何属性（`frame`、`bounds`、`transform`），处理 Auto Layout 约束，确定视图在屏幕上的位置和尺寸。  
  - 框架：依赖 **Core Animation** 的 `CALayer` 布局系统（如 `layoutSublayers`），通过 `UIView` 的 `layoutSubviews` 触发。

- **内容准备（Content Preparation）**  
  - 职责：  
    - 加载和解码图像（如 PNG/JPEG 转位图），生成 `CGImage` 或 `UIImage`。  
    - 绘制文本、路径或自定义图形（如 `UIBezierPath`、`drawRect`）。  
    - 处理图层属性（如圆角 `cornerRadius`、阴影 `shadowPath`），判断是否需要 **离屏绘制（Offscreen Rendering）**。  
  - 框架：  
    - **Core Graphics（Quartz 2D）**：用于自定义图形绘制（如 `CGContext` 绘图）。  
    - **Core Image**：可选，用于图像预处理（如滤镜、色彩调整）。  
    - **Core Animation**：管理 `CALayer` 的属性（如 `contents`、`mask`）。

- **提交图层树到渲染线程**  
  - 职责：将主线程的图层树（`CALayer` 层级）打包成 **渲染描述符（Rendering Descriptor）**，传递给后台渲染线程（非主线程）。  
  - 框架：**Core Animation** 负责维护图层树，并通过 `CATransaction` 异步提交更新。

#### **2. GPU 阶段：图形渲染与合成**
- **纹理创建与上传（Texture Upload）**  
  - 职责：将 CPU 准备的位图数据（如 `CGImage`）转换为 **GPU 纹理（Texture）**，并从系统内存（RAM）上传到 GPU 内存（VRAM）。  
  - 框架：依赖 **Core Animation** 底层的 **Metal**（iOS 8+）或 **OpenGL ES**，由 GPU 驱动自动处理。

- **渲染管线处理（Render Pipeline）**  
  - **顶点处理（Vertex Shading）**：  
    - 职责：将视图的几何形状（如矩形）转换为顶点坐标，应用 `transform` 变换（平移、缩放等），生成图元（Primitives）。  
    - 框架：由 **Metal/OpenGL ES** 底层着色器（Shader）实现，**Core Animation** 间接控制参数（如顶点数据）。  
  - **光栅化（Rasterization）**：  
    - 职责：将图元（如三角形）转换为像素网格（片段），确定每个像素的位置。  
    - 框架：GPU 硬件内置功能，无上层框架直接介入。  
  - **片段着色（Fragment Shading）**：  
    - 职责：对每个像素片段采样纹理颜色，应用图层属性（如透明度 `alpha`、混合模式 `blendMode`）、滤镜（如 `CIFilter`）或遮罩（`mask`）。  
    - 框架：  
      - **Core Image**：若使用滤镜，会在此时通过 GPU 加速计算（如 `CIContext` 渲染滤镜链）。  
      - **Core Animation**：控制片段混合逻辑（如图层叠加顺序、透明度）。

- **图层合成（Layer Compositing）**  
  - 职责：将多个图层的纹理按层级顺序混合（Blend），生成最终画面。  
  - 框架：**Core Animation** 负责管理图层层级和混合模式，底层通过 **Metal/OpenGL ES** 的混合管线实现。


### **二、核心框架的角色定位**
| **框架**          | **阶段**       | **具体作用**                                                                 |
|-------------------|----------------|-----------------------------------------------------------------------------|
| **Core Graphics** | CPU 渲染准备  | - 提供 2D 绘图 API（如 `CGContext` 绘制路径、文本、图像）。<br>- 生成 `CGImage` 位图数据。 |
| **Core Animation**| 全流程协调    | - 管理 `CALayer` 图层树，控制布局、动画和层级关系。<br>- 异步提交图层更新到渲染线程。<br>- 与 GPU 交互，驱动纹理合成和混合。 |
| **Core Image**    | CPU/GPU 处理  | - CPU 阶段：构建滤镜处理链（如 `CIFilter` 序列）。<br>- GPU 阶段：通过 `CIContext` 在渲染管线中执行滤镜计算（如高斯模糊、色彩校正）。 |
| **Metal/OpenGL ES**| GPU 底层驱动 | - 直接控制 GPU 渲染管线（顶点着色、光栅化、片段着色）。<br>- 由 `Core Animation` 间接调用，无需上层代码直接操作。 |


### **三、关键问题解析**
#### **1. 为什么 Core Animation 是核心协调者？**
- `CALayer` 是 iOS 渲染的基础单元，所有视图（`UIView`）的显示均依赖其底层图层。  
- **Core Animation** 不仅负责动画逻辑，还管理图层的几何属性、层级关系和渲染状态，是连接 CPU 准备阶段与 GPU 渲染阶段的桥梁。

#### **2. Core Image 何时介入渲染？**
- 当需要对图像应用滤镜（如 `CIGaussianBlur`）或复杂图像处理时，**Core Image** 会在 CPU 阶段构建滤镜图（Filter Graph），并在 GPU 片段着色阶段通过 `CIContext` 执行并行计算，利用 GPU 算力加速处理。

#### **3. 离屏绘制与框架的关系？**
- 当图层属性（如圆角+阴影）无法通过 GPU 直接合成时，**Core Animation** 会触发离屏绘制：  
  - CPU 或 GPU 在独立缓冲区（Offscreen Buffer）中提前渲染效果，再将结果合并到主画面。  
  - 过度使用离屏绘制会增加 CPU/GPU 负担，需通过 **Core Animation 调试工具**（如 Xcode 的 Color Offscreen-Rendered Yellow）优化。


### **四、总结：渲染流程与框架协作图**
```
CPU 阶段：
UIView 布局计算（Core Animation） → 图像解码/绘制（Core Graphics） → 滤镜处理（Core Image） → 图层树提交（Core Animation）

GPU 阶段：
纹理上传（Metal） → 顶点/片段着色（Metal） → 图层合成（Core Animation 控制混合） → 双缓冲区交换（VSync 同步）
```

通过 **Core Animation** 的协调，**Core Graphics** 和 **Core Image** 在 CPU 阶段完成数据准备，最终由 **Metal/OpenGL ES** 驱动 GPU 完成渲染，实现高效的图形管线处理。理解各框架的角色有助于针对性优化渲染性能（如避免主线程阻塞、减少 GPU 合成压力）。


图片怎么显示的，以及图片缓冲区
如果使用imagename那么图片在显示的时候解码 解码之后显示在屏幕上 - 有内存缓存 
所以我们优化的时候 最好是在 自线程解码

NSObject结构体里面有什么，大小为什么是16字节
isa指针 - 属性 -成员变量 - 方法 - 协议
实际是8字节 - 规定最小为16字节

KVO怎么实现，_会不会触发，成员变量会不会触发，kvc+成员变量会不会触发，不用setter怎么触发kvo
isa-swing计数 生成自己的子类将isa指针指向这个子类 子类重写方法 willchang 和didichange 来实现
不回 不调用set方法

操作系统内存布局，有什么区
代码区 数据区 堆区 栈区

一个OC对象的内存布局

滑动优化怎么搞

什么是runtime，什么是runloop，有几种mode

NSObject的内存布局

isa指针和super指针

元类是什么
存类方法的类

所有OC对象都继承与NSObject吗，id是什么

SDWebImage的清除缓存策略

block是什么

LRU算法怎么实现

Swift和OC的方法调用

两个链表的公共结点

链表中环开始的地方，原理说出来

项目里面最体现你技术的点。

三面
1.什么是hash

2.hash的具体实现，程序里面一个对象怎么通过hash定位到具体的内存区。

3.hash数组扩容

4.一个天平，4个砝码，能秤出多少种重量。

/*
 key 映射到value 分两步
 1.计算原始哈希值
 2.经过一些算法 将hash值 转换为数组的下标
 
 
 属于第二种的算法：
 直接取余
 乘积取整法
 乘积取整法首先使用关键字 k 乘以一个常数 A(0<A<1),并抽取出 kA 的小数部分,然后用 hash 表大小 m 乘以这个值,再取整数部分即可
 
 
 1.什么是hash 计算hash值
 不同长度的输入经过hash函数变换成固定长度的输出 就是hash值

 2.hash的具体实现，程序里面一个对象怎么通过hash定位到具体的内存区。
  计算出hash的具体实现有 1.iOS中直接返回内存地址 2.Times33[就是对字符串逐字符迭代乘以33] 2.SHA-1
  计算出hash值之后在经过一些算法得到数组的下标
 
 3.hash数组扩容 = NSDictionary + NSArray 组合
 哈希表
 当存储的数据超过总数的一定比列的时候就需要扩容了 java中的负载因子时0.75 通过扩大底层数组的容量来减少哈希冲突，维持哈希表的性能
 每个元素需要重新hash

 4.一个天平，4个砝码，能秤出多少种重量。
 1.砝码都不一样的话 就是 3 + 2 + 1 + 4 + 4 + 1
 



 */
