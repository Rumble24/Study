字节一面内容：
1、  自我介绍

2、  介绍一下简历中的一个项目

3、  面向对象的三个要素
继承 封装 多态

4、  多态？
多态，即对于不同对象响应同一个方法时做出的不同反应。


OC 的多态建立在 动态运行时（Dynamic Runtime） 机制之上，核心是通过 objc_msgSend 函数实现 消息发送 的动态解析。
OC 的多态通过 动态消息传递 和 运行时特性，实现了 “同一接口，不同实现” 的编程范式。其核心价值在于：
OC 的运行时特性与多态结合，支持在运行时动态替换实现类，无需重新编译。

5、  Java，python，OC运行效率孰高？
Java是半编译半解释型语言 是用的是垃圾回收机制 效率较低 编译为字节码 现代的话 是运行在androud runtime上面 启动的时候会进行一次编译存在本地 所以现在的安卓比以前也快
 OC是编译为机器吗，采用的是引用计数的内存管理 比较简单 但是高效 而且和硬件相结合 运行较快
 python是解释型语言 运行最慢 变运行变解释
 
 编译型语言是直接编译为机器码运行
 解释型语言是需要翻译为字节码 然后在解释器上运行
 
 swift相比于oc 的话
 调用函数对比 oc是基于rumtime 的 objc——msgsend 动态调用
 swift默认使用 静态调度（编译时确定方法地址 更快
 swift有类型检查 很多问题可以在编译的时候发现
 swift默认使用结构体值引用。// 类实例本身存于堆内存，因此结构体属性的值（包括 Array）会作为类实例的一部分存于堆中。
 oc默认使用指针引用 需要引用计数
 
 而且swift默认使用的是写时复制 比如使用array我们使用的时候是使用的统一快内存 一旦发生写入操作 才会进行拷贝操作
6、  Property，其中copy如何？
 有copy操作默认实现了nscopying协议 写了 copywithzone
 写一个单例模式
 
 static Manager* _instance;
 
 + (instancetype)shareInstance {
  if(!_instance) {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
      _instace = [[self alloc]init];
   });
  }
  return _instance;
 }
 
 +(instancetype)allocWithZone(NSzone *)zone {
 if(!_instance) {
   static dispatch_once_t onceToken;
   dispatch_once(&onceToken, ^{
     _instace = [super allocWithZone:zone];
  });
 }
 return _instance;
 }

 7、  Property(nonatomatic, copy) NSMutableArray有什么问题
  会变成不可变的对象 调用可变对象的方法 会发生找不到方法的崩溃
 8、  Copy和MutableCopy的区别

 9、  解释下类别，原理
 类别可以为系统类/自己的类增加方法 合理使用可以极大提高代码的质量
 原理是runtime启动的时候会将类别的方法添加在自己类的前面
 不同的分类增加同一个方法 是按照 后编译的添加在恰面
 分类调用load方法 先调用父类的在调用 这个类的 在调用分类的 分类的调用顺序 和编译顺序有光
 
 分类最好不要谢 initialize 方法因为 initialize走的是 objc_msg方法 会覆盖类的 initialize方法
 父类实现了initialize方法 有多个子类的时候 父类的 initialize 会调用多次
 如果子类实现了 initialize 那么 如果父类没有调用 会调用父类的方法
 [BaseController initialize]
 +[ViewController initialize]
 +[BaseController initialize]
 + (void)initialize {
     if (self == [BaseController class]) {
         NSLog(@"%s", __func__);
     }
 }
 这么写的话 可以避免调用多次

10、解释下封装，重载；

11、 OC存在多重继承吗？

12、了解表视图吗，解释一下复用原理

13、说明一下表视图的滑动卡顿的优化方法

14、viewDidLoad和viewDidAppear的调用时机（一次和多次的区别）；

15、页面间的传值方式有哪些（公有属性，公有方法和协议，block传值，通知，extern全局变量传值，NSUserDefault简单数据存储传值）；

16、通知和delegate的区别？

 17、 通知的发送和接收是否在同一线程？
 默认是同一个线程 可以指定接受的线程

 18、HTTP和HTTPS区别？
 客户端发起1还有支持的算法到服务器
 服务器发起2还有公钥到客户端
 客户端将3使用公要加密发给服务器
 服务器用私钥解密得到3 然后用123对话密钥。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 AES 算法
 .客户端 C 通知服务端 S 后面的通信用对话密钥进行加密来完成，同时通知服务器 S 客户端 C 的握手过程结束。
 7.服务端 S 通知客户端 C后面的通信用对话密钥进行加密来完成，同时通知客户端C 服务器 S 的握手过程结束。
 8.SSL/TLS 的握手部分结束，SSL 安全通道的数据传输开始，客户端 C 和服务器 S 开始使用相同的对话密钥进行数据传输。

19、OC中多线程一般有几个方案？

20、了解NSURLConnection和Session吗？

21、说一下NSURLSession具体的实现原理

22、http的头部的几个码。；

23、编程题：实现一个二叉树的倒置。

字节二面内容：
1、老虎吃羊问题。（博弈论，老虎要吃羊，假设所有老虎是理智的，即首先为了生存，其次为了饱腹，老虎吃了羊后会变成羊，同样会被其他老虎吃掉。现在，N只老虎和1只羊，请问N为多少时，老虎们会吃羊。动态规划问题，奇数吃，偶数不吃。）

2、青蛙跳格子，斐波拉契数列；青蛙跳格子，斐波拉契数列；

3、熟悉使用什么框架？

4、如果让你自己实现SDWebImage的二级存储机制，你如果实现？
1.1）为何不直接使用 NSCache？ --> 系统自行清理缓存，清理时间内容无法自行控制


5、@autorelease{ NSString s;}和NSString s;有什么区别？

6、说一下你对autorelease的理解。

7、说一下对于http的理解？

8、http的返回状态码有了解吗？

9、为什么说http是无状态的？

10、为什么不用原生的APNS技术实现呢？

11、了解GCD吗？

12、说一下dispatch_group_t和dispatch_barrier_sync的区别吗？

13、了解NSOperation吗？

14、了解NSOperationQueue吗？

字节三面内容：
1、  算法题：求只有三项元素的数组中的顺序排列，时间复杂度要求O(n)；

2、  说一下你对OC程序编译和连接方面的理解？

3、  说一下内存管理相关的操作？

4、  说一下响应链的原理？

5、  追问：hitTest有尝试过重写吗？

6、  http, session和cookie有了解过吗；

7、  线程和队列的关系？

8、  CALayer和UIView了解吗？
/*
 6、说一下你对autorelease的理解。
 如果通过代码添加一个autoreleasepool，在作用域结束时，随着pool的释放，就会释放pool中的对象。这种情况是及时释放的，并不依赖于runloop。
 另一种就是由系统自动进行释放，系统会在runloop开始的时候创建一个pool，结束的时候会对pool中的对象执行release操作
 
 调用 [obj autorelease] 会将对象加入当前自动释放池，并返回对象本身。
 对象的引用计数不会立即减 1，而是在自动释放池销毁时才减 1（延迟释放）。
 
 7、说一下对于http的理解？
 http主要是用来传输数据的，规定了数据的传输规则他是我们现在互联网的基础
 主要有几个特点
 无状态 每个连接是独立的 都要进行 tcp3次握手 传输数据 断开链接
 请求-响应模型
 支持多种数据结构
 http1.1只吃了长链接 多个请求可以使用同一个链接 客户端可以主动关闭/服务端设置多久没有使用就关闭 在 HTTP/1.1 中，默认启用长连接，无需显式设置 Connection: keep-alive 头。
 
 在 HTTP/1.1 中，多个请求虽复用同一连接，但请求是按顺序发送的。若第一个请求因某种原因（如服务器处理延迟）阻塞，后续请求即使已准备好，也需等待前一个请求完成，导致整体延迟增加。
 示例：客户端依次请求资源 A、B、C，A 因服务器繁忙响应缓慢，B 和 C 需等待 A 完成后才能被处理。
 在http2.中 解决了这个问题 通过二进制分帧和多路复用，允许单个连接并行传输多个请求 / 响应，彻底解决队头阻塞。
 
 9、为什么说http是无状态的？
 每次请求都是独立的 不会保存上次请求的状态 不知道每次请求是谁在请求
 我们可以使用cookie//token来解决这个问题，每次请求的时候携带这个信息 来保持状态
 在 HTTP/1.1 中虽支持长连接（复用 TCP 连接），但连接本身不存储状态，服务器仍将每个请求视为独立操作。

 6、  http, session和cookie有了解过吗；

 
 2、  说一下你对OC程序编译和连接方面的理解？
我们的代码经过 预处理 词法分析 与法分析 然后编译 汇编 链接[将多个 .o 目标文件 和 库文件（Library） 合并为一个 可执行文件（]生成我们的可执行文件 mach-o
 
 预处理会替进行头文件引入，宏替换，注释处理，条件编译(#ifdef)等操作。
 Clang前端负责分析源代码语法分析，语义分析，并构建针对该语言的抽象语法树（AST）
 词法分析器读入源文件的字符流，将他们组织称有意义的词素(lexeme)序列，对于每个词素，此法分析器产生词法单元（token）作为输出
 语法分析，词法分析的Token流会被解析成一颗抽象语法树(abstract syntax tree - AST)
 AST 是抽象语法树，结构上比代码更精简，遍历起来更快，所以使用 AST 能够更快速地进行静态检查，同时还能更快地生成 LLVM IR（中间代码）
 最后 AST 会生成 LLVM IR，LLVM IR 是一种更接近机器码的语言，区别在于和平台无关，通过 IR 可以生成多份适合不同平台的机器码。对于 iOS 系统，IR 生成的可执行文件就是 Mach-O
 优化器统一对前端生成的中间代码LLVM IR进行代码优化
 LLVM 对中间代码IR进行优化，并针对不同架构生成目标文件，以汇编代码的形式进行输出
 汇编阶段，将上一步生成的汇编代码转化成机器代码，最终以.o文件进行输出
 链接器ldb(静态链接),将汇编生成的.o文件和（dylib、.a、tbd）文件进行链接生成可执行文件（Mac-O）

 作者：火柴盒环游记
 链接：https://www.jianshu.com/p/f432a05e0ca7
 来源：简书
 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 
 3、  说一下内存管理相关的操作？

 4、  说一下响应链的原理？
 寻找事件最佳响应者（Hit-Testing）内部调用了point inset

 5、  追问：hitTest有尝试过重写吗？
 7、  线程和队列的关系？

 */
