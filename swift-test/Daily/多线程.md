- (void)taskAction {
    dispatch_async(self.queueB, ^{
        NSLog(@"任务0 %@", NSThread.currentThread);
        dispatch_sync(self.queueA, ^{
            // 任务1
            NSLog(@"任务1 %@", NSThread.currentThread);
            dispatch_async(self.queueB, ^{
                NSLog(@"任务2 %@", NSThread.currentThread);
                dispatch_async(self.queueA, ^{
                    NSLog(@"任务3 %@", NSThread.currentThread);
                });
            });
            NSLog(@"任务4 %@", NSThread.currentThread);
        });
    });
}

- (void)taskAction1 {
    dispatch_sync(self.queueA, ^{
        // 任务1
        NSLog(@"任务1");
        dispatch_sync(self.queueB, ^{
            // 任务2
            NSLog(@"任务2");
        });
        // 任务3必须在任务2完成后才可以继续
        NSLog(@"任务3");
    });
}


/*
 同步的情况下 任务里面潜逃任务
 是指多个进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的僵局，若无外力干涉则无法继续推进
 1.同步线程 串行队列 里面再次嵌套 同步线程 同一个串行队列
 dispatch_sync(self.queueA, ^{
     NSLog(@"任务1");
     dispatch_sync(self.queueA, ^{
         NSLog(@"任务2");
     });
     NSLog(@"任务3");
 });
 2.在同一线程中，嵌套使用同步锁（如 @synchronized、NSLock），且锁顺序不一致
 3.dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
 
 // 线程 1
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
     dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
     // 执行任务
     dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 再次等待，导致死锁
     // 永远不会执行到这里
 });
 
 同步锁嵌套    同一线程重复获取不可重入锁    使用可重入锁（如 NSRecursiveLock）或避免嵌套
 主队列同步调用    主线程被 dispatch_sync 阻塞    改用 dispatch_async 异步提交任务
 多锁循环等待    不同线程以相反顺序获取锁    统一锁获取顺序，使用 NSConditionLock 强制顺序
 信号量使用不当    同一线程重复 wait 信号量    确保 wait 和 signal 成对出现，初始值设置合理
 串行队列同步提交到自身    队列任务被阻塞    改用异步提交或并发队列
 
 
 两个串行队列 任务 只要有一个同步 线程
 */
